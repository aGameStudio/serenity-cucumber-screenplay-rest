# serenity-cucumber-screenplay-rest

This is a demo project for Serenity + Cucumber + Screenplay + REST

### The project directory structure
The project has build scripts for Maven, and follows the standard directory structure used in most Serenity projects:
```Gherkin
src
  + main
  + test
    + java                        Test runners and supporting code
    + resources
      + features                  Feature files
        + search                  Feature file subdirectories
             get_product.feature
```

## Executing the tests
To run the sample project, you can either just run the `CucumberTestSuite` test runner class, or run `mvn verify` from the command line.

The test results will be recorded in the `target/site/serenity` directory. Open `index.html` to see report in browser.

## Generating the reports
Since the Serenity reports contain aggregate information about all of the tests, they are not generated after each individual test (as this would be extremenly inefficient). Rather, The Full Serenity reports are generated by the `serenity-maven-plugin`. You can trigger this by running `mvn serenity:aggregate` from the command line or from your IDE.

They reports are also integrated into the Maven build process: the following code in the `pom.xml` file causes the reports to be generated automatically once all the tests have completed when you run `mvn verify`.

```
            <plugin>
                <groupId>net.serenity-bdd.maven.plugins</groupId>
                <artifactId>serenity-maven-plugin</artifactId>
                <version>${serenity.version}</version>
                <executions>
                    <execution>
                        <id>serenity-reports</id>
                        <phase>post-integration-test</phase>
                        <goals>
                            <goal>aggregate</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
```

## The sample scenario
The project uses the sample Cucumber scenario. In this scenario, Taras (who likes to call a Search API for a specific keyword) is performing a REST call:

Note: that scenario uses Background steps as a preconditions and Examples section to run the same scenario for different test input data.

```Gherkin
Feature: Search for the product

  Background:
    Given Taras can call the API

  Scenario Outline: positive

    When he searches for an <keyword>
    Then he sees the results displayed for an <keyword>

    Examples:
      | keyword |
      | "orange"|
      | "apple" |
```

### The Screenplay implementation
The sample code in the master branch uses the Screenplay pattern. The Screenplay pattern describes tests in terms of actors and the tasks they perform. Tasks are represented as objects performed by an actor, rather than methods. This makes them more flexible and composable, at the cost of being a bit more wordy. Here is an example:
```java
    @Given("{actor} can call the API")
    public void actorCan(Actor actor) {
        actor.whoCan(CallAnApi.at(theRestApiBaseUrl));
    }

    @When("{actor} searches for an {string}")
    public void searchesFor(Actor actor, String keyword) {
        actor.attemptsTo(
        CallSearchAPI.withKeyword(keyword)
        );
    }

    @Then("{actor} sees the results displayed for an {string}")
    public void heSeesResultFor(Actor actor, String item) {
        actor.should(
            seeThatResponse(String.format("all the search result titles should contain %s keyword", item),
                response -> response.statusCode(200)
                    .body("title", everyItem(containsStringIgnoringCase(item))))
        );
    }
```

Screenplay classes emphasise reusable components and a very readable declarative style, whereas Action Classes (that you can see further down) opt for a more imperative style.

The `CallSearchAPI` class is responsible for colling a REST endpoint to get search results by specific keyword.:
```java
public class CallSearchAPI {

    private static final String PATH = "/api/v1/search/demo/{itemName}";

    public static Performable withKeyword(String itemName) {
        return Task.where("{0} call search an item API with keyword " + itemName,
                Get.resource(PATH)
                        .with(request -> request.pathParam("itemName", itemName))
        );
    }
}
```
NOTE: te base URL specified in `resources/serenity.conf` as `restapi.baseurl` and needed to run tests via `CucumberTestSuite.java`
Base URL for running tests via maven is specified in `pom.xml` as `<restapi.baseurl>`

The Screenplay DSL is rich and flexible, and well suited to teams working on large test automation projects with many team members, and who are reasonably comfortable with Java and design patterns. 
